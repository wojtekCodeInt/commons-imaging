# Fuzzing the Apache Commons Imaging Java Image Library

## What is Commons Imaging?

Apache Commons Imaging, previously known as Apache Commons Sanselan, is a library 
that reads and writes a variety of image formats, including fast parsing of 
image info (size, color space, ICC profile, etc.) and metadata. 

## What is fuzzing (in a nutshell)?

Fuzzing is a dynamic code analysis technique that supplies pseudo-random inputs
to a software-under-test (SUT), derives new inputs from the behaviour of the
program (i.e. how inputs are processed), and monitors the SUT for bugs.

## How can fuzzing improve this application

By sending unexpected inputs to the parsers, fuzzing can trigger erroneous behaviour.
In case of Java applications, CI Fuzz detects and reports all unhandled exceptions,
which by itself can often point developers at bugs and vulnerabilities. 
There are also detectors for specific vulnerabilities, for example insecure deserialization, SQL and LDAP injections
and others.

## Fuzzing where raw data is handled

Fuzzing is most efficient where raw data is parsed, because in this case no
assumptions can be made about the format of the input. Commons Imaging allows you to process
arbitrary data using a collection of parsers for different image formats including jpeg, pgn, bnp and gif.


The most universal example of this type of fuzz test can be found in
[`.code-intelligence/fuzz_targets/AllImageParser.java`](https://github.com/ci-fuzz/commons-imaging/blob/master/.code-intelligence/fuzz_targets/AllImageParser.java).
Let me walk you through the heart of the fuzz test:

```Java
public class AllImageParser {
// 1. The function fuzzerTestOneInput will be repeatedly executed using data generated by the fuzzer as input
// Use the fuzz data provider for easy, deterministic conversion of the fuzz input to the needed data types
	public static void fuzzerTestOneInput(FuzzedDataProvider data) {

		final BufferedImage image;
		try{
// 3. Get a byte array of a length depending on the fuzzer input
			byte[] imagebytes = data.consumeBytes(data.consumeInt(1,Integer.MAX_VALUE));
// 4. Try to parse the bytes as image. The format is guessed automatically.
			image = Imaging.getBufferedImage(imagebytes);
			//Call some more funcitons that try to parse image metadata
			final ImageMetadata metadata = Imaging.getMetadata(imagebytes);
			final ICC_Profile iccProfile = Imaging.getICCProfile(imagebytes);
			final ImageInfo imageInfo = Imaging.getImageInfo(imagebytes);

// 5. Catch exceptions that are expected to be thrown when the image parser gets malformed input data.
// If a exception is catched, return immediately so the fuzzer can try a new input.
		} catch(ImageReadException | IOException e){
			return;
		}

// 6. Select a target format based on the fuzzer input
		final ImageFormat format = ImageFormats.values()[data.consumeInt(0,14)];
		final Map<String, Object> params = new HashMap<>();

		try{
// 7. Try to write the image that was parsed succesfully above into the target format
        	Imaging.writeImageToBytes(image, format, params);
		} catch(ImageWriteException | IOException e){
			return;
		}
	}
}
```

If you haven't done already, you can now explore what the fuzzer found when
running this fuzz test.

## A note regarding corpus data (and why there are more fuzz tests to explore)

For each fuzz test that we write, a corpus of interesting inputs is built up.
Over time, the fuzzer will add more and more inputs to this corpus, based
coverage metrics such as newly-covered lines, statements or even values in an
expression.

## Fuzzing in CI/CD

If integrated in the CI/CD fuzzing can help to find regressions or bugs in new code before early in the process.
This reduces costs and effort fixing them and supports you delivering reliable and secure software.
Once setup, the CI/CD integration can be used to fuzz every new commit made to selected branches
or to fuzz pull requests before they are merged. The corpus data from previous fuzzing runs is used, 
enabling the fuzzer to use its prior knowledge of the application.

 

The fuzzing is done on a dedicated fuzzing server. We recommend using the Code Intelligence SaaS solution.
For enterprises also on-premise server installation in possible.

The results can be viewed in the CI-Fuzz web app, enabling developers that are not familiar with fuzzing
to view and fix the bugs found by the fuzzer.

CI Fuzz allows you to configure your pipeline to automatically trigger the run of fuzz tests.
Most of the fuzzing runs that you can inspect here were triggered automatically (e.g. by this
pull request on the GitHub project: [`https://github.com/ci-fuzz/zint/pull/47`](https://github.com/ci-fuzz/zint/pull/47)).
With this configuration comes the hidden strength of fuzzing into play:
Fuzzing is not like a penetration test where your application will be tested one time only.
Once you have configured your fuzz test it can help you for the whole rest of your developing cycle.
By running your fuzz test each time when some changes where made to the source code you can quickly check for
regressions and also quickly identify new introduced bugs that would otherwise turn up possibly months 
later during a penetration test or (even worse) in production. This can help to significantly reduce the bug ramp down phase of any project.

While these demo projects are configured to trigger fuzzing runs on merge or pull requests
there are many other configuration options for integrating fuzz testing into your CI/CD pipeline
for example you could also configure your CI/CD to run nightly fuzz tests.

## Where you can go from here  
